#include "sys/time.h"
#include "signal.h"

int TASK_AGING = -1;

#define quantum 20

struct sigaction action;

struct itimerval timer;

unsigned int lastQuantum = 0;

void setTimer()
{
    timer.it_value.tv_usec = 1000;    // primeiro disparo, em micro-segundos
    timer.it_interval.tv_usec = 1000; // disparos subsequentes, em micro-segundos
    timer.it_value.tv_sec = 0;
    timer.it_interval.tv_sec = 0;

    if (setitimer(ITIMER_REAL, &timer, 0) < 0) {
        perror("Erro em setitimer: ");
        exit(1);
    }
}

void sig_Handler(int sinal) {
    systemTime++;

    if (systemTime - lastQuantum < quantum) { return; } // early return para quando a tarefa estiver dentro do quantum

    if (taskExec->state == 'X') {
        taskExec->state = 'S';
    }
    task_t *nextTask = scheduler();
    if (nextTask != NULL) {
        if (nextTask->state == 'S') {
            nextTask->state = 'X';
        }
        task_yield();
    }
    lastQuantum = systime();
}

void set_handler() {
    action.sa_handler = sig_Handler;
    sigemptyset(&action.sa_mask);
    action.sa_flags = 0;
    if (sigaction(SIGALRM, &action, 0) < 0) {
        perror("Erro em sigaction: ");
        exit(1);
    }
}

int task_getprio(task_t *task) {
    if (task == NULL) {
        task = taskExec;
    }
    return task->staticPriority;
}

void task_setprio(task_t *task, int prio) {
    if (prio < -20) {
        prio = -20;
    } else if (prio > 20) {
        prio = 20;
    }

    if (task == NULL) {
        task = taskExec;
    }
    task->staticPriority = prio;
    task->dynamicPriority = prio;
}

int task_getdprio(task_t *task)  {
    if (task == NULL) {
        task = taskExec;
    }
    return task->dynamicPriority;
}

void task_agedprio(task_t *task, int aging) {
    if (task == NULL) {
        task = taskExec;
    }
    if (aging == 0) {
        task->dynamicPriority = task_getprio(task);
    }

    if (task->dynamicPriority + aging < -20) {
        task->dynamicPriority = -20;
        return;
    } else if (task->dynamicPriority + aging > 20) {
        task->dynamicPriority = 20;
        return;
    }

    task->dynamicPriority += aging;
}

task_t *scheduler() {
    if (readyQueue == NULL) {
        return NULL;
    }

    task_t *prioTask = readyQueue;
    task_t *it = readyQueue;

    do {
        if (task_getdprio(it) <= task_getdprio(prioTask) && it != prioTask) {
            task_agedprio(prioTask, TASK_AGING);
            prioTask = it;
        } else if (it != prioTask) {
            task_agedprio(it, TASK_AGING);
        }
        it = it->next;
    } while (it != NULL && it->id != 0 && it != readyQueue);

    task_agedprio(prioTask, 0);

    return prioTask;
}

void printContab(task_t *task) {
    printf("Task %d exit: execution time %d ms, processorTime %d ms, %d activations\n", task->id, systemTime - task->startTime, task->processorTime, task->activations);
}

void before_ppos_init()
{
    setTimer();
    set_handler();
}

void before_task_create(task_t *task) {
    task->processorTime = 0;
    task->activations = 0;
    task->startTime = systime();
}

void before_task_exit() {
    printContab(taskExec);
}

void before_task_switch(task_t *task)
{
    task->state = 'X';
    task->lastActivation = systime();
    task->activations++;
    if(task == taskMain && systime() > 0 && countTasks == 1) { // processos já terminaram e pode imprimir a contabilização da main
        printContab(taskExec);
    }
}

void before_task_yield() {
    taskExec->processorTime += (systime() - taskExec->lastActivation);
}